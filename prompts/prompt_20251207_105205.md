**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0xa049332b836855cda28e3fba747385d8cbd785042e96595e2607dac575bd62b8`
- **Module Name:** `contract`
- **Available Methods:**

  * `create_debate` (constant: `CREATE_DEBATE`)
  * `join_debate` (constant: `JOIN_DEBATE`)
  * `get_topic` (constant: `GET_TOPIC`)
  * `get_description` (constant: `GET_DESCRIPTION`)
  * `get_side_a_count` (constant: `GET_SIDE_A_COUNT`)
  * `get_side_b_count` (constant: `GET_SIDE_B_COUNT`)
  * `get_total_participants` (constant: `GET_TOTAL_PARTICIPANTS`)
  * `get_participant_side` (constant: `GET_PARTICIPANT_SIDE`)
  * `has_joined` (constant: `HAS_JOINED`)

---

# **Move Contract: `contract/micro_debate_arena/sources/micro_debate_arena.move`**

```move
module micro_debate_arena::contract {
use std::string::String;
use iota::event;
use iota::table::{Self, Table};
const E_ALREADY_JOINED: u64 = 1;
const E_INVALID_SIDE: u64 = 2;
public struct Debate has key {
id: UID,
topic: String,
description: String,
side_a_count: u64,
side_b_count: u64,
total_participants: u64,
participants: Table<address, u8>,
}
public struct DebateCreated has copy, drop {
debate_id: ID,
topic: String,
description: String,
creator: address,
}
public struct JoinedDebate has copy, drop {
debate_id: ID,
participant: address,
side: u8,
}
public entry fun create_debate(
topic: String,
description: String,
ctx: &mut TxContext
) {
let debate_id = object::new(ctx);
let debate_id_copy = object::uid_to_inner(&debate_id);
let debate = Debate {
id: debate_id,
topic,
description,
side_a_count: 0,
side_b_count: 0,
total_participants: 0,
participants: table::new(ctx),
};
event::emit(DebateCreated {
debate_id: debate_id_copy,
topic: debate.topic,
description: debate.description,
creator: ctx.sender(),
});
transfer::share_object(debate);
}
public entry fun join_debate(
debate: &mut Debate,
side: u8,
ctx: &mut TxContext
) {
let sender = ctx.sender();
assert!(side == 0 || side == 1, E_INVALID_SIDE);
assert!(!table::contains(&debate.participants, sender), E_ALREADY_JOINED);
table::add(&mut debate.participants, sender, side);
if (side == 0) {
debate.side_a_count = debate.side_a_count + 1;
} else {
debate.side_b_count = debate.side_b_count + 1;
};
debate.total_participants = debate.total_participants + 1;
event::emit(JoinedDebate {
debate_id: object::uid_to_inner(&debate.id),
participant: sender,
side,
});
}
public fun get_topic(debate: &Debate): String {
debate.topic
}
public fun get_description(debate: &Debate): String {
debate.description
}
public fun get_side_a_count(debate: &Debate): u64 {
debate.side_a_count
}
public fun get_side_b_count(debate: &Debate): u64 {
debate.side_b_count
}
public fun get_total_participants(debate: &Debate): u64 {
debate.total_participants
}
public fun get_participant_side(debate: &Debate, participant: address): Option<u8> {
if (table::contains(&debate.participants, participant)) {
option::some(*table::borrow(&debate.participants, participant))
} else {
option::none()
}
}
public fun has_joined(debate: &Debate, participant: address): bool {
table::contains(&debate.participants, participant)
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK
 * ============================================================================
 * 
 * This hook contains ALL the contract interaction logic.
 * 
 * To customize your dApp, modify the configuration section below.
 * 
 * ============================================================================
 */

import { useState, useEffect } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"
import type { IotaObjectData } from "@iota/iota-sdk/client"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================
// Change these values to match your Move contract

export const CONTRACT_MODULE = "contract" // Your Move module name
export const CONTRACT_METHODS = {
  CREATE_DEBATE: "create_debate",
  JOIN_DEBATE: "join_debate",
} as const

// ============================================================================
// DATA EXTRACTION
// ============================================================================
// Modify this to extract data from your contract's object structure

function getObjectFields(data: IotaObjectData): { value: number; owner: string } | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType)
    return null
  }
  
  const fields = data.content.fields as any
  if (!fields) {
    console.log("No fields found in object data")
    return null
  }
  
  // Log the actual structure for debugging
  console.log("Object fields structure:", JSON.stringify(fields, null, 2))
  
  // Handle value - it might be a string (u64) or number
  let value: number
  if (typeof fields.value === "string") {
    value = parseInt(fields.value, 10)
    if (isNaN(value)) {
      console.log("Value is not a valid number:", fields.value)
      return null
    }
  } else if (typeof fields.value === "number") {
    value = fields.value
  } else {
    console.log("Value is not a number or string:", typeof fields.value, fields.value)
    return null
  }
  
  // Handle owner - convert to string
  if (!fields.owner) {
    console.log("Owner field is missing")
    return null
  }
  
  const owner = String(fields.owner)
  
  return {
    value,
    owner,
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  value: number
  owner: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  createObject: () => Promise<void>
  increment: () => Promise<void>
  reset: () => Promise<void>
  clearObject: () => void
}

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()
  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  // Load object ID from URL hash
  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  // Fetch object data
  const { data, isPending: isFetching, error: queryError, refetch } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
    }
  )

  // Extract fields
  const fields = data?.data ? getObjectFields(data.data) : null
  const isOwner = fields?.owner.toLowerCase() === address?.toLowerCase()
  
  // Check if object exists but data extraction failed
  const objectExists = !!data?.data
  const hasValidData = !!fields

  // Create object
  const createObject = async () => {
    if (!packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CREATE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })
              const newObjectId = effects?.created?.[0]?.reference?.objectId
              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
                // Reset loading - the query will handle its own loading state
                setIsLoading(false)
              } else {
                setIsLoading(false)
                console.warn("No object ID found in transaction effects")
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError)
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error creating object:", err)
      setIsLoading(false)
    }
  }

  // Increment
  const increment = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.INCREMENT}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error incrementing:", err)
      setIsLoading(false)
    }
  }

  // Reset
  const reset = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId), tx.pure.u64(0)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.SET_VALUE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error resetting:", err)
      setIsLoading(false)
    }
  }

  const contractData: ContractData | null = fields
    ? {
        value: fields.value,
        owner: fields.owner,
      }
    : null

  const clearObject = () => {
    setObjectId(null)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const actions: ContractActions = {
    createObject,
    increment,
    reset,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: (isLoading && !objectId) || isPending || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: contractData,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
  }
}


```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

/**
 * ============================================================================
 * MICRO-DEBATE ARENA - MAIN UI COMPONENT
 * ============================================================================
 * 
 * This is the main UI for the Micro-Debate Arena dApp on IOTA.
 * Users can create debates and join sides.
 * 
 * ============================================================================
 */

import { useState, useEffect } from "react"
import { useCurrentAccount, useIotaClient, useSignAndExecuteTransaction } from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"
import { Button, Container, Heading, Text } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

interface Debate {
  id: string
  topic: string
  description: string
  sideACount: number
  sideBCount: number
  totalParticipants: number
  participants: Map<string, number>
}

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute } = useSignAndExecuteTransaction()
  
  const [debates, setDebates] = useState<Debate[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [showCreateForm, setShowCreateForm] = useState(false)
  const [topic, setTopic] = useState("")
  const [description, setDescription] = useState("")
  const [expandedDebate, setExpandedDebate] = useState<string | null>(null)
  const [txStatus, setTxStatus] = useState<string>("")

  const isConnected = !!currentAccount

  // Fetch all debates
  useEffect(() => {
    if (!packageId || !isConnected) return

    const fetchDebates = async () => {
      try {
        setIsLoading(true)
        // Query all Debate objects owned by the package
        const response = await iotaClient.getOwnedObjects({
          owner: currentAccount!.address,
          filter: {
            StructType: `${packageId}::contract::Debate`,
          },
          options: {
            showContent: true,
            showOwner: true,
          },
        })

        const debateList: Debate[] = response.data
          .map((item) => {
            const data = item.data
            if (!data || data.content?.dataType !== "moveObject") return null

            const fields = data.content.fields as any
            return {
              id: data.objectId,
              topic: fields.topic || "",
              description: fields.description || "",
              sideACount: parseInt(fields.side_a_count || "0"),
              sideBCount: parseInt(fields.side_b_count || "0"),
              totalParticipants: parseInt(fields.total_participants || "0"),
              participants: new Map(),
            }
          })
          .filter((d): d is Debate => d !== null)

        setDebates(debateList)
      } catch (error) {
        console.error("Error fetching debates:", error)
      } finally {
        setIsLoading(false)
      }
    }

    fetchDebates()
    const interval = setInterval(fetchDebates, 5000) // Refresh every 5 seconds
    return () => clearInterval(interval)
  }, [packageId, isConnected, iotaClient, currentAccount])

  // Create debate
  const handleCreateDebate = async () => {
    if (!topic.trim() || !description.trim()) {
      alert("Please fill in both topic and description")
      return
    }

    setIsLoading(true)
    setTxStatus("Creating debate...")

    try {
      const tx = new Transaction()
      tx.moveCall({
        target: `${packageId}::contract::create_debate`,
        arguments: [tx.pure.string(topic), tx.pure.string(description)],
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: (result) => {
            console.log("Debate created:", result)
            setTxStatus("‚úì Debate created successfully!")
            setTopic("")
            setDescription("")
            setShowCreateForm(false)
            setTimeout(() => setTxStatus(""), 3000)
          },
          onError: (error) => {
            console.error("Error creating debate:", error)
            setTxStatus("‚úó Failed to create debate")
            setTimeout(() => setTxStatus(""), 3000)
          },
        }
      )
    } catch (error) {
      console.error("Error:", error)
      setTxStatus("‚úó Failed to create debate")
      setTimeout(() => setTxStatus(""), 3000)
    } finally {
      setIsLoading(false)
    }
  }

  // Join debate
  const handleJoinDebate = async (debateId: string, side: 0 | 1) => {
    setIsLoading(true)
    setTxStatus(`Joining Side ${side === 0 ? "A" : "B"}...`)

    try {
      const tx = new Transaction()
      tx.moveCall({
        target: `${packageId}::contract::join_debate`,
        arguments: [tx.object(debateId), tx.pure.u8(side)],
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: (result) => {
            console.log("Joined debate:", result)
            setTxStatus(`‚úì Joined Side ${side === 0 ? "A" : "B"}!`)
            setTimeout(() => setTxStatus(""), 3000)
          },
          onError: (error) => {
            console.error("Error joining debate:", error)
            setTxStatus("‚úó Failed to join debate")
            setTimeout(() => setTxStatus(""), 3000)
          },
        }
      )
    } catch (error) {
      console.error("Error:", error)
      setTxStatus("‚úó Failed to join debate")
      setTimeout(() => setTxStatus(""), 3000)
    } finally {
      setIsLoading(false)
    }
  }

  if (!isConnected) {
    return (
      <div style={{ minHeight: "calc(100vh - 200px)", display: "flex", alignItems: "center", justifyContent: "center", padding: "2rem" }}>
        <div style={{ textAlign: "center", maxWidth: "500px" }}>
          <div style={{ fontSize: "4rem", marginBottom: "1rem" }}>üó≥Ô∏è</div>
          <Heading size="6" style={{ marginBottom: "1rem" }}>Micro-Debate Arena</Heading>
          <Text style={{ color: "var(--gray-11)" }}>
            Connect your wallet to create debates and join discussions
          </Text>
        </div>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "calc(100vh - 200px)", padding: "2rem", background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)", backgroundAttachment: "fixed" }}>
      <Container style={{ maxWidth: "1200px", margin: "0 auto" }}>
        {/* Header */}
        <div style={{ textAlign: "center", marginBottom: "3rem", color: "white" }}>
          <div style={{ fontSize: "3rem", marginBottom: "0.5rem" }}>üó≥Ô∏è</div>
          <Heading size="8" style={{ marginBottom: "0.5rem", color: "white" }}>Micro-Debate Arena</Heading>
          <Text size="4" style={{ color: "rgba(255,255,255,0.9)" }}>
            Choose your side. Make your voice heard.
          </Text>
        </div>

        {/* Status Message */}
        {txStatus && (
          <div style={{ 
            marginBottom: "2rem", 
            padding: "1rem", 
            background: txStatus.startsWith("‚úì") ? "rgba(34, 197, 94, 0.2)" : txStatus.startsWith("‚úó") ? "rgba(239, 68, 68, 0.2)" : "rgba(59, 130, 246, 0.2)", 
            borderRadius: "12px",
            border: "1px solid rgba(255,255,255,0.3)",
            color: "white",
            textAlign: "center",
            fontWeight: "600"
          }}>
            {txStatus}
          </div>
        )}

        {/* Create Debate Button/Form */}
        <div style={{ marginBottom: "2rem" }}>
          {!showCreateForm ? (
            <Button
              size="3"
              onClick={() => setShowCreateForm(true)}
              style={{ 
                background: "white", 
                color: "#667eea",
                fontWeight: "700",
                cursor: "pointer",
                border: "none",
                boxShadow: "0 4px 12px rgba(0,0,0,0.15)"
              }}
            >
              + Create New Debate
            </Button>
          ) : (
            <div style={{ background: "white", borderRadius: "16px", padding: "2rem", boxShadow: "0 8px 24px rgba(0,0,0,0.2)" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "1.5rem" }}>
                <Heading size="5">Create New Debate</Heading>
                <button
                  onClick={() => setShowCreateForm(false)}
                  style={{ background: "none", border: "none", fontSize: "1.5rem", cursor: "pointer", color: "#666" }}
                >
                  ‚úï
                </button>
              </div>
              
              <div style={{ marginBottom: "1rem" }}>
                <Text size="2" style={{ display: "block", marginBottom: "0.5rem", fontWeight: "600" }}>Topic</Text>
                <input
                  type="text"
                  value={topic}
                  onChange={(e) => setTopic(e.target.value)}
                  placeholder="e.g., Cats vs Dogs"
                  maxLength={100}
                  style={{ 
                    width: "100%", 
                    padding: "0.75rem", 
                    border: "2px solid #e5e7eb", 
                    borderRadius: "8px",
                    fontSize: "1rem",
                    outline: "none"
                  }}
                  onFocus={(e) => e.target.style.borderColor = "#667eea"}
                  onBlur={(e) => e.target.style.borderColor = "#e5e7eb"}
                />
              </div>

              <div style={{ marginBottom: "1.5rem" }}>
                <Text size="2" style={{ display: "block", marginBottom: "0.5rem", fontWeight: "600" }}>Description</Text>
                <textarea
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="e.g., Which makes a better pet?"
                  maxLength={500}
                  style={{ 
                    width: "100%", 
                    padding: "0.75rem", 
                    border: "2px solid #e5e7eb", 
                    borderRadius: "8px",
                    fontSize: "1rem",
                    minHeight: "100px",
                    resize: "vertical",
                    outline: "none"
                  }}
                  onFocus={(e) => e.target.style.borderColor = "#667eea"}
                  onBlur={(e) => e.target.style.borderColor = "#e5e7eb"}
                />
              </div>

              <div style={{ display: "flex", gap: "0.75rem" }}>
                <Button
                  size="3"
                  onClick={handleCreateDebate}
                  disabled={isLoading}
                  style={{ flex: 1, background: "#667eea", cursor: "pointer" }}
                >
                  {isLoading ? <ClipLoader size={16} color="white" /> : "Create Debate"}
                </Button>
                <Button
                  size="3"
                  variant="outline"
                  onClick={() => setShowCreateForm(false)}
                  style={{ cursor: "pointer" }}
                >
                  Cancel
                </Button>
              </div>
            </div>
          )}
        </div>

        {/* Debates List */}
        {isLoading && debates.length === 0 ? (
          <div style={{ textAlign: "center", padding: "3rem", color: "white" }}>
            <ClipLoader size={40} color="white" />
            <Text style={{ marginTop: "1rem", color: "white" }}>Loading debates...</Text>
          </div>
        ) : debates.length === 0 ? (
          <div style={{ textAlign: "center", padding: "3rem", background: "rgba(255,255,255,0.1)", borderRadius: "16px", border: "2px dashed rgba(255,255,255,0.3)" }}>
            <div style={{ fontSize: "3rem", marginBottom: "1rem" }}>üí¨</div>
            <Text size="5" style={{ color: "white", display: "block", marginBottom: "0.5rem" }}>No debates yet</Text>
            <Text style={{ color: "rgba(255,255,255,0.8)" }}>Be the first to create a debate!</Text>
          </div>
        ) : (
          <>
            <Heading size="6" style={{ marginBottom: "1.5rem", color: "white" }}>
              Active Debates ({debates.length})
            </Heading>
            <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(350px, 1fr))", gap: "1.5rem" }}>
              {debates.map((debate) => {
                const total = debate.sideACount + debate.sideBCount
                const sideAPercent = total > 0 ? (debate.sideACount / total) * 100 : 50
                const sideBPercent = total > 0 ? (debate.sideBCount / total) * 100 : 50
                const isExpanded = expandedDebate === debate.id

                return (
                  <div
                    key={debate.id}
                    style={{
                      background: "white",
                      borderRadius: "16px",
                      overflow: "hidden",
                      boxShadow: "0 8px 24px rgba(0,0,0,0.15)",
                      transition: "transform 0.2s",
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.transform = "translateY(-4px)"}
                    onMouseLeave={(e) => e.currentTarget.style.transform = "translateY(0)"}
                  >
                    <div style={{ padding: "1.5rem" }}>
                      <Heading size="4" style={{ marginBottom: "0.5rem", color: "#1f2937" }}>
                        {debate.topic}
                      </Heading>
                      <Text size="2" style={{ color: "#6b7280", display: "block", marginBottom: "1rem", lineHeight: "1.5" }}>
                        {debate.description}
                      </Text>

                      {/* Stats */}
                      <div style={{ display: "flex", alignItems: "center", gap: "0.5rem", marginBottom: "1rem", color: "#6b7280", fontSize: "0.875rem" }}>
                        <span>üë•</span>
                        <span>{total} participants</span>
                      </div>

                      {/* Progress Bar */}
                      <div style={{ marginBottom: "1rem" }}>
                        <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.75rem", fontWeight: "600", marginBottom: "0.25rem" }}>
                          <span style={{ color: "#3b82f6" }}>Side A: {debate.sideACount}</span>
                          <span style={{ color: "#a855f7" }}>Side B: {debate.sideBCount}</span>
                        </div>
                        <div style={{ position: "relative", height: "12px", background: "#e5e7eb", borderRadius: "999px", overflow: "hidden" }}>
                          <div style={{ position: "absolute", height: "100%", background: "#3b82f6", width: `${sideAPercent}%`, transition: "width 0.3s" }} />
                          <div style={{ position: "absolute", height: "100%", background: "#a855f7", width: `${sideBPercent}%`, left: `${sideAPercent}%`, transition: "width 0.3s, left 0.3s" }} />
                        </div>
                        <div style={{ display: "flex", justifyContent: "space-between", fontSize: "0.75rem", color: "#9ca3af", marginTop: "0.25rem" }}>
                          <span>{sideAPercent.toFixed(1)}%</span>
                          <span>{sideBPercent.toFixed(1)}%</span>
                        </div>
                      </div>

                      {/* Join Buttons */}
                      <div style={{ display: "flex", gap: "0.5rem" }}>
                        <Button
                          size="2"
                          onClick={() => handleJoinDebate(debate.id, 0)}
                          disabled={isLoading}
                          style={{ flex: 1, background: "#3b82f6", cursor: "pointer" }}
                        >
                          Join Side A
                        </Button>
                        <Button
                          size="2"
                          onClick={() => handleJoinDebate(debate.id, 1)}
                          disabled={isLoading}
                          style={{ flex: 1, background: "#a855f7", cursor: "pointer" }}
                        >
                          Join Side B
                        </Button>
                      </div>
                    </div>

                    {/* Details Toggle */}
                    <button
                      onClick={() => setExpandedDebate(isExpanded ? null : debate.id)}
                      style={{ 
                        width: "100%", 
                        background: "#f9fafb", 
                        padding: "0.75rem", 
                        border: "none", 
                        borderTop: "1px solid #e5e7eb",
                        cursor: "pointer",
                        fontSize: "0.875rem",
                        color: "#6b7280"
                      }}
                    >
                      {isExpanded ? "Hide Details ‚ñ≤" : "Show Details ‚ñº"}
                    </button>

                    {/* Expanded Details */}
                    {isExpanded && (
                      <div style={{ padding: "1.5rem", background: "#f9fafb", borderTop: "1px solid #e5e7eb" }}>
                        <Text size="1" style={{ display: "block", marginBottom: "0.5rem", fontWeight: "600", color: "#6b7280" }}>
                          Debate ID
                        </Text>
                        <Text size="1" style={{ fontFamily: "monospace", wordBreak: "break-all", color: "#9ca3af" }}>
                          {debate.id}
                        </Text>
                      </div>
                    )}
                  </div>
                )
              })}
            </div>
          </>
        )}
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0xa049332b836855cda28e3fba747385d8cbd785042e96595e2607dac575bd62b8` and Module: `contract`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
